import org.jetbrains.kotlin.gradle.plugin.mpp.KotlinNativeTarget
import org.jetbrains.kotlin.gradle.targets.jvm.KotlinJvmTarget

import static co.touchlab.cklib.gradle.CompileToBitcode.Language.C
import static org.gradle.language.base.plugins.LifecycleBasePlugin.BUILD_GROUP
import static org.gradle.language.base.plugins.LifecycleBasePlugin.VERIFICATION_GROUP
import static org.jetbrains.kotlin.gradle.plugin.KotlinCompilation.MAIN_COMPILATION_NAME
import static org.jetbrains.kotlin.gradle.plugin.KotlinCompilation.TEST_COMPILATION_NAME

apply plugin: 'org.jetbrains.kotlin.multiplatform'
apply from: "$rootDir/addAllTargets.gradle"
apply from: "$rootDir/publish.gradle"
apply plugin: 'co.touchlab.cklib'
apply plugin: 'com.jakewharton.cite'
apply plugin: 'dev.drewhamilton.poko'
apply plugin: 'com.jakewharton.mosaic.build'

mosaicBuild {
	jvmTestDistribution()
}

configurations {
	proGuard
}

dependencies {
	proGuard 'com.guardsquare:proguard-base:7.6.1'
}

kotlin {
	explicitApi()

	sourceSets {
		configureEach {
			languageSettings.optIn('kotlin.contracts.ExperimentalContracts')
		}

		commonTest {
			dependencies {
				implementation libs.kotlin.test
				implementation libs.kotlinx.io
				implementation libs.kotlinx.coroutines.core
				implementation libs.assertk
			}
		}
	}

	targets.withType(KotlinJvmTarget).configureEach { target ->
		def mainCompilation = target.compilations.named(MAIN_COMPILATION_NAME)
		def testCompilation = target.compilations.named(TEST_COMPILATION_NAME)

		mainCompilation.configure { main ->
			tasks.named(main.processResourcesTaskName).configure {
				doFirst {
					def jniDir = file("src/${target.name}Main/resources/jni")
					def files = project.fileTree(jniDir).files
					if (files.size() != 6) {
						throw new RuntimeException("""Native library mismatch!
							|
							|Run `zig build -p $jniDir`.
							|
							|Expected 6 files, found:
							|- """.stripMargin() + files.collect { jniDir.relativePath(it) }.sort().join('\n -'))
					}
				}
			}
		}

		def allJvmTests = tasks.register("all${target.name.capitalize()}Tests") {
			group = VERIFICATION_GROUP
			description = "Run all of the tests for the ${target.name} target."
		}

		// Create dedicated compilation tasks for each LTS JDK as well as the latest JDK. One of these
		// may be redundant with the normal test task, but that depends on the user's JDK version,
		// and we don't really care about the duplication because these run very quickly.
		for (testJdk in [8, 11, 17, 21, 23]) {
			target.testRuns.create("Jdk$testJdk") { run ->
				allJvmTests.configure {
					it.dependsOn(run.executionTask)
				}
				run.executionTask.configure { test->
					test.javaLauncher = javaToolchains.launcherFor {
						it.languageVersion = JavaLanguageVersion.of(testJdk)
					}
				}
			}
		}

		def dependencyFiles = testCompilation.map { it.runtimeDependencyFiles }
		def proGuardJar = base.archivesName.flatMap { archivesName ->
			layout.buildDirectory.file("libs/$archivesName-tests-${target.name}-$version-ProGuard.jar")
		}
		def proGuardTask = tasks.register("${target.name}TestJarProGuard", JavaExec) {
			group = BUILD_GROUP
			description = 'Assembles an archive containing the test classes run through ProGuard.'

			inputs.files(configurations.proGuard)
			inputs.files(dependencyFiles)
			outputs.file(proGuardJar.get())

			classpath(configurations.proGuard)
			mainClass = 'proguard.ProGuard'
			args = [
				'-libraryjars', '<java.home>/jmods/java.base.jmod(!**.jar;!module-info.class)',
				// TODO These should be pulled from the jars, but for now this unblocks us.
				'@src/jvmMain/resources/META-INF/proguard/com.jakewharton.mosaic-terminal.pro',
				'@src/jvmTest/resources/META-INF/proguard/com.jakewharton.mosaic-terminal-test.pro',
			]

			doFirst {
				// Defer resolving this until execution time since JavaExec lacks provider-based args.
				args += '-injars'
				args += dependencyFiles.get().files.join(File.pathSeparator)
				// These do not need deferred, but since it must come after -injars it has to go here.
				args += '-outjars'
				args += proGuardJar.get().asFile.toString()
			}
		}

		target.testRuns.create("ProGuard") { run ->
			allJvmTests.configure {
				it.dependsOn(run.executionTask)
			}
			run.executionTask.configure {
				dependsOn(proGuardTask)
			}
			run.setExecutionSourceFrom(
				project.files(proGuardJar.get()),
				dependencyFiles.get().filter { it.isDirectory() },
			)
		}

		// Adding additional test runs somehow removes the configuration capabilities which allow
		// automatic resolution of the junit test dependency. Add it explicitly instead.
		testCompilation.configure {
			dependencies {
				implementation(libs.kotlin.test.junit)
			}
		}
	}

	def linkNativeDebugTests = tasks.register('linkNativeDebugTests')

	targets.withType(KotlinNativeTarget).configureEach {
		compilations.main.cinterops {
			create('mosaic') {
				header(file('src/c/mosaic.h'))
				packageName('com.jakewharton.mosaic.terminal')
			}
		}
		linkNativeDebugTests.configure {
			it.dependsOn(compilations.test.binariesTaskName)
		}
	}

	compilerOptions.freeCompilerArgs.add('-Xexpect-actual-classes')
	compilerOptions.freeCompilerArgs.add('-Xnon-local-break-continue')
}

cklib {
	config.kotlinVersion = libs.versions.kotlin.get()
	create('mosaic', file('src/c'), ['main']) {
		it.srcDirs = files('src/c')
		it.language = C
	}
}
